=======================================================================

       File Name: MessageLib200.txt

       Description: Message Library Ver2.00 設計ドキュメント

       Notes: (C) Copyright 2012,2013,2014,2017 Sony Corporation

       Author: Tomonobu Hayakawa
       Author: Suzunosuke Hida

=======================================================================

------------------------------------------------------------------------
1. 概要
------------------------------------------------------------------------

	MessageLibは、CPU間で共有するメモリ領域に配置したメッセージキューを
	通じたメッセージ送受信機能を提供する。
	CPU内、CPU間を問わずにシームレスなメッセージ送受信を行うことができる。

	ただし、CPU間のメッセージ送受信では、メッセージパラメタにポインタや
	MemHandle等、CPU毎の意味を持つデータが含まれないように注意すること。


------------------------------------------------------------------------
2. 用語
------------------------------------------------------------------------

	本文書で使用する用語について、以下に説明する。

	・メッセージキューID
	　メッセージキューをシステム全体で一意に識別するための値。
	　Ver1.xxでのDTQ-IDにあたるものである。
	　メッセージキューレイアウト生成ツールにより、自動的に生成される。
	　ID値の0は、MessageLibで予約済みである。

	・メッセージパケット
	　メッセージパケットは、タイプID、リプライキューID、送信元CPU-ID、メッ
	　セージパラメタ長およびオプションのメッセージパラメタから構成される。

	・タイプID
	　メッセージ種別を識別するための値。
	　MessageLibでは内容に関知しないので、PJ毎に使用方法を規定すること。

	・リプライキューID
	　メッセージの返信先のメッセージキューID。
	　MessageLibでは内容に関知しないので、PJ毎に使用方法を規定すること。

	・CPU-ID
	　CPUを一意に識別するための値。主にMessageLib内部で使用される。

	・メッセージパラメタ
	　タイプIDに関連付けされた追加のパラメタ。

	・共有キュー
	　CPU間通信をサポートするキュー。


------------------------------------------------------------------------
3. 機能
------------------------------------------------------------------------

3.1 機能概要

	MessageLibは、以下の機能を提供する。

	・タスクコンテキストでのメッセージパケットの送受信

	・非タスクコンテキストでのメッセージパケットの送信
	　(ただしスピンロック待ちを避けるため、共有キューには送信不可)

	・メッセージパラメタに、クラスインスタンスを使用可能
	　この機能により、明示的なコピーコンストラクタを持つインスタンスを
	　安全に送受信できる。(ただしCPU間では、非常に単純なクラスのもののみ)

	・CPU間でのOSの有無を問わない送受信(CPU間通信機構があるCPU間のみ)

	・送信時にメッセージパケットの優先度を指定可能

	・受信待ち時間を指定可能

	・メッセージパラメタのサイズチェック

	・オプションで、メッセージシーケンスのログを取得可能

	・オプションで、CPU内メッセージのパラメタの型チェックが可能


3.2 旧バージョン(Ver1.xx)との機能の差異

	・Ver1.xxでは、メッセージのタイプIDの内容を細かく規定していたが
	　Ver2.00では、内容を規定しない。そのため、Message::get_subtype()等の
	　タイプの詳細を取得するAPIは廃止された。PJ毎に別途内容を規定すること。

	・Ver1.xxでは、ITRONを搭載したCPU内部での送受信のみが可能だったが
	　Ver2.00では、OSの有無によらずCPU間も含めた送受信が可能。メッセージを
	　独自のキューで管理する構成に変更したので、該当領域をダンプすることで
	　メッセージキュー毎の受信履歴が確認できる。10.5節を参照のこと。

	・Ver1.xxでは、ITRONのデータキューと固定長メモリプールに依存していたが
	　Ver2.00では、ITRONに依存しない。ただしOS環境では、受信待ちを実現する
	　ため、キュー毎にセマフォリソースを必要とする。

	・Ver1.xxに存在した、Message::get_dtop()は廃止された。
	　Ver2.00では、MsgPacket::peekParamOther<int>()で代用することができる。

	・Ver1.xxでは、送信完了までブロックするAPI(Message::send)が存在するが
	　Ver2.00では、即時復帰して送信結果を返すAPI(Message::psend相当)のみと
	　なる。完了待ちを行うには、別途待ち合わせ用のOSリソースが必要で、制御
	　の複雑化を招き、更にはCPU間送信でのサポートが困難なためである。

	以下は、Ver2.00での新機能となる

	・受信完了待ち時間を指定可能

	・パラメタなしメッセージもリプライキューIDを指定できる

	・パラメタつきメッセージを非タスクコンテキストから送信可能

	・送信時に優先度を指定可能

	・キュー内のメッセージ数や空き状態を取得可能

	・送受信でメッセージパラメタのサイズチェックが可能

	・CPU内メッセージのパラメタの型チェックが可能


------------------------------------------------------------------------
4. データ構造
------------------------------------------------------------------------

4.1 メッセージキューブロック

　CPU間で共有されるメモリ領域(Fixed領域など)に、以下の形式のデータを配置する

  MsgQueBlockの配列
  +-+-------------+
  | | init        | キュー初期化完了フラグ
  | +-------------+
  | | owner       | キュー所有者(受信者)のCPU-ID
  | +-------------+
  | | spinlock_id | スピンロックID。0ならばCPU間の共有なし
  | +-------------+
  |1| msg_count   | 総メッセージ数を示す計数セマフォまたはカウンタ
  | +-------------+
  | | msg_que[0]  | 通常優先度キューの管理領域
  | +-------------+
  | | msg_que[1]  | 高優先度キューの管理領域(未使用の場合あり)
  | +-------------+
  | | cur_que     | 受信処理中のキューを示す
  +-+-------------+
         ...       
  +-+-------------+
  | | init        |
  | +-------------+
  | | owner       |
  | +-------------+
  | | spinlock_id |
  | +-------------+
  |n| msg_count   |         メッセージ格納領域
  | +-------------+                    +--------+
  | | msg_que[0]  | -----------------> |        |
  | +-------------+        +--------+  |        |
  | | msg_que[1]  | -----> |        |  |  data  |
  | +-------------+        |        |  |        |
  | | cur_que     |        |  data  |  |        |
  +-+-------------+        |        |  +--------+
                           |        |
                           +--------+


4.2 メッセージパケット

　メッセージ格納領域に、以下の形式のデータを配置する

    MsgPacket
  +------------+
  | type       | タイプID(16bit)
  +------------+
  | reply      | リプライキューID(16bit)
  +------------+
  | src_cpu    | 送信元CPU-ID(8bit)
  +------------+
  | flags      | 拡張用のフラグ群(8bit)。現在はライブラリ内部使用のみ
  +------------+
  | param_size | パラメタ長(16bit)。0ならばパラメタなし
  +------------+
  |            |
  | param      | オプションのパラメタ
  |            |
  +------------+


------------------------------------------------------------------------
5. 動作概要
------------------------------------------------------------------------

5.1 送信 (MsgQueへのpush操作)

	if (非共有キュー) {
		スコープドCPUロック
		if (指定優先度の送信先キューに空きなし)
			return キューフルエラー
		メッセージパケットを該当キューへ入れる
		キューの総メッセージ数を示す計数セマフォのUP操作を行う
	} else {
		スコープドスピンロック
		if (指定優先度の送信先キューに空きなし)
			return キューフルエラー
		メッセージパケットを該当キューへ入れる
		該当領域のキャッシュフラッシュ
		if (自CPU所有キュー)
			キューの総メッセージ数を示す計数セマフォのUP操作を行う
		else
			CPU間通信機構を通じて受信CPUにキューの計数セマフォUP操作を依頼 (※ユーザー実装)
	}
	return 正常終了

5.2 CPU間通信割込み (※ユーザー実装)

	if (割込み要因はメッセージ送信通知) {
		キューの総メッセージ数を示す計数セマフォのUP操作を行う
	}

5.3 受信 (MsgQueへのpeek操作)

	キューの総メッセージ数を示す計数セマフォのDOWN操作を行う
	if (DOWN操作がタイムアウト)
		return NULL
	if (共有キュー)
		該当領域のキャッシュクリア
	優先度の最も高いキューのメッセージパケットへのポインタを取得
	return メッセージパケットへのポインタ

5.4 破棄 (MsgQueへのpop操作)

	if (非共有キュー) {
		スコープドCPUロック
		キューからメッセージパケットを破棄する
	} else {
		スコープドスピンロック
		キューからメッセージパケットを破棄する
		キュー管理領域のキャッシュフラッシュ
	}


------------------------------------------------------------------------
6. メッセージキューレイアウト
------------------------------------------------------------------------

6.1 定義ファイル

  メッセージキューレイアウト定義ファイル(msgq_layout.conf)のサンプルを以下に示す。

	# ユーザー定義定数は、"U_"で始まる英大文字・数字の名称とすること
	# "U_MSGQ_"で始まる名称で定義すると、msgq_id.hにdefineマクロとしても出力される
	U_CYC_SIZE = 16
	U_CYC_NUM  = 8

	###############################################################################
	# メッセージキュープールの定義
	#
	#   ID:         メッセージキュープールIDの名称を、"MSGQ_"で始まる文字列で指定。
	#               以下は、予約済みのため使用禁止。
	#               "MSGQ_NULL", "MSGQ_TOP", "MSGQ_END"
	#
	#   n_size:     通常優先度キューの各要素のバイト数(8以上512以下)。
	#               固定ヘッダ長(8byte) + パラメタ長を4の倍数で指定する。
	#               共有キューの場合はツール内で、64の倍数の値に切り上げられる。
	#
	#   n_num:      通常優先度キューの要素数(1以上16384以下)。
	#
	#   h_size:     高優先度キューの各要素のバイト数(0または、8以上512以下)。
	#               未使用時は0を指定すること。
	#               固定ヘッダ長(8byte) + パラメタ長を4の倍数で指定する。
	#               共有キューの場合はツール内で、64の倍数の値に切り上げられる。
	#
	#   h_num:      高優先度キューの要素数(0または、1以上16384以下)。
	#               未使用時は0を指定すること。
	#
	#   owner:      キューの所有者。spl_layout.confで定義したCPU-IDのいずれかを指定する。
	#               キューの所有者のみが、メッセージを受信できる。
	#
	#   spinlock:   非共有キューは空文字列を指定する。
	#               共有キューは、spl_layout.confで定義したスピンロックIDのいずれかを指定する。
	#               共有キューは、送受信ともにオーバーヘッドが大きいため、大量のメッセージの
	#               やりとりは避けること。
	#
	MsgQuePool = [
	# [ ID                 n_size      n_num      h_size h_num owner         spinlock
	  ["MSGQ_SPU0_CYCLIC", U_CYC_SIZE, U_CYC_NUM, 0,     0,    "CPUID_SPU0", ""],
	  ["MSGQ_SPU1_CYCLIC", U_CYC_SIZE, U_CYC_NUM, 0,     0,    "CPUID_SPU1", ""],
	  ["MSGQ_SPU_CMD",     256,        32,        16,    4,    "CPUID_SPU0", "SPL_SPU_SPH"],
	  nil # end of user definition
	] # end of MsgQuePool

	###############################################################################
	# デバッグ用に、メッセージpop後の領域を埋める値を8bitで指定する
	# 0の時は領域埋めを行わない。デバッグ時以外は、0を指定すること
	#
	MsgFillValueAfterPop = 0x00

	###############################################################################
	# メッセージパラメタの型が送受信で一致するかのチェックの有無を指定する
	# チェックは、const/volatileを含めて厳密に行われる
	# CPU内メッセージのみが対象となる
	# trueを指定すると要素サイズが8より大きいキューの各要素に4バイトの領域が追加され
	# 処理時間も増加する。ISS環境以外では、通常はfalseを指定すること
	#
	MsgParamTypeMatchCheck = false


6.2 コマンド

  メッセージキューレイアウト生成コマンドの書式を以下に示す。

	Usage:
            ruby msgq_layout.conf StartDRM Size IdHeader PoolHeader
                     or
            ruby msgq_layout.conf FixedHeader FixedID IdHeader PoolHeader
                     or
            ruby msgq_layout.conf FixedHeader FixedID IdHeader PoolHeader CoreID

        ex) ruby msgq_layout.conf 0x00800000 0x20000 msgq_id.h msgq_pool.h
                     or
	    ruby msgq_layout.conf mem_fixed_layout.h MSG_QUE_AREA msgq_id.h msgq_pool.h
                     or
        ruby msgq_layout.conf mem_fixed_layout.h MSG_QUE_AREA msgq_id.h msgq_pool.h CPUID_6

  コマンド引数

	StartDRM, Size		メッセージ領域のDRMアドレスとバイト単位の領域サイズ
	FixedHeader, FixedID	Fixed領域のヘッダとメッセージ領域のID
	IdHeader		メッセージキューIDマクロが出力されるファイル
	PoolHeader		メッセージキュープールの定義が出力されるファイル
	CoreID			指定したコア用のメッセージブロックを生成する

------------------------------------------------------------------------
7. ビルド方法
------------------------------------------------------------------------

7.1 ユーザー実装

	共有キューを使用するCPU向けに、下記の実装をユーザーが行う必要がある。
	共有キュー未使用のCPU向けには、ユーザー実装は必要ない。

	(1) メッセージを送信したことを他CPUへ通知する関数

	　　sample/MsgNotify.hを雛形として、CPU間通信処理を実装する。

	(2) CPU間通信割込みハンドラ

	　　割込み要因がメッセージ送信通知の時に、MsgLib::notifyRecv()を呼出すこと。


7.2 使用リソース

7.2.1 計数セマフォ

	SailOS+を利用する場合は、Makefile.sailで自CPU所有のメッセージキュー数
	分のセマフォを予約する必要がある。
	MemoryManagerやDumpLib等のセマフォ予約とあわせて、合計で40個のセマフォ
	を予約する場合の例を示す。

               CFG_CMD = -VRSV_SEM\(40\)

	OSなし環境では、下記のマクロ定義が必要となる。

		-DUSE_NO_OS_SEMAPHORE
		-DCYCLE_PER_MS=1msをカウントするためのCPUサイクル (CPU周波数/4000位か?)
		-DTNUM_SEM=自CPU所有のメッセージキュー数


7.2.2 スピンロック(CPU間共有メッセージキュー使用時のみ)

	SpinLockManager.txtに従い、使用するスピンロックを定義すること


7.3 コンパイル・オプション

	Versionを指定する必要があるため、下記のMake変数を設定する必要がある。

		MESSAGE_LIB_VERSION = 2.00

	また、インクルードパス指定（-Iオプション）には下記変数を使用すること。

		$(INC_MESSAGE_LIB_DIR)

	なお、Ver1.xxで必要だった以下の定義は不要となる。

		・Config/config.mkのMPL_MSG_NUMとMPL_MSG_SIZEの定義

		・SailCfg/Makefile.sailの-DMPL_MSG_MAX_NUMおよび-DMPL_MSG_MAX_SIZEの定義

		・SailCfg/system.cfgのCRE_DTQおよびCRE_MPFの定義


7.4 リンカ・オプション

	下記の形式で、_cpu_offsetをオプション指定する必要がある。

	--defsym _cpu_offset=$(XXX_MAIN_OFFSET)


------------------------------------------------------------------------
8. API仕様
------------------------------------------------------------------------

8.1 型定義

  メッセージライブラリのAPIで使用される型を以下に示す。

	typedef uint16_t MsgType;	/* メッセージタイプID */
	typedef uint16_t MsgQueId;	/* メッセージキューID */
	typedef uint8_t  MsgCpuId;	/* メッセージCPU-ID */
	typedef uint8_t  MsgFlags;	/* メッセージフラグ */

	enum MsgPri {			/* メッセージ優先度 */
		MsgPriNormal,
		MsgPriHigh,
		NumMsgPri
	};


8.2 API

  メッセージライブラリを使用するには、以下のヘッダファイルをインクルードする

	#include "MsgLib.h"

  以下のAPIの説明で、ASSERTすると記述されている箇所は、全てD_ASSERTを使用して
  いるため、NDEBUGマクロを定義するとNOPとなる。


8.2.1 MsgLibクラス

8.2.1.1 全体の初期化

  -----------------------------------------------------------------------
  [関数]  static err_t MsgLib::initFirst()
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] ERR_OK       : 初期化成功
           ERR_STS      : 2回以上、本関数を実行している

  [説明]   メッセージライブラリ全体の初期化を行う。
	本ライブラリの他のAPIを使用する前に、事前に取り決めた単一のCPUで一回
	だけ本関数を実行すること。

  [互換性] なし

8.2.1.2 initFirst 初期化状態の取得関数

  -----------------------------------------------------------------------
  [関数]  static bool MsgLib::isInitFirstComplete()
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] true:  初期化済み(initFirst 関数で初期化が完了している)
           false: 未初期化

  [説明]   initFirst 関数での初期化状態を取得する。

  [互換性] なし

8.2.1.3 CPU毎の初期化

  -----------------------------------------------------------------------
  [関数]  static err_t MsgLib::initPerCpu()
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] ERR_OK       : 初期化成功
           ERR_STS      : MsgLib::initFirst()が未実行

  [説明]   メッセージライブラリのCPU毎の初期化を行う。
	CPU毎の各種領域や計数セマフォ(OS環境のみ)の初期化など。

	本ライブラリを使用する全てのCPUは、MsgLib::initFirst()の実行完了を
	待ってから、本関数を実行する必要がある。

	MsgLib::initFirst()が未実行の場合は、ASSERTする。
	既に本APIを実行済みのCPUで、再度本APIを実行した場合は、ASSERTする。

  [互換性] なし


8.2.1.4 メッセージキューの初期化状態の取得

  -----------------------------------------------------------------------
  [関数]  static err_t MsgLib::isInitComplete(MsgQueId id, bool &done)
  -----------------------------------------------------------------------

  [引数]   MsgQueId    id    : メッセージキューID
           bool        &done : メッセージキューの初期化状態(true:初期化済み false 未初期化)

  [戻り値] ERR_OK  : 初期化状態の取得成功
           ERR_ARG : 引数idの示すメッセージキューブロックが存在しない
           ERR_STS : MsgLib::initFirst()が未実行

  [説明]   メッセージキューの初期化状態を取得し、引数&doneに出力する。

  [互換性] なし


8.2.1.5 メッセージパケットの送信

  -----------------------------------------------------------------------
  [関数]  static err_t MsgLib::send(MsgQueId dest, MsgPri pri, MsgType type, MsgQueId reply)

          static err_t send(MsgQueId dest, MsgPri pri, MsgType type, MsgQueId reply, const void* param, size_t param_size)

          template<typename T>
          static err_t MsgLib::send(MsgQueId dest, MsgPri pri, MsgType type, MsgQueId reply, const T& param)

          static err_t MsgLib::sendIsr(MsgQueId dest, MsgPri pri, MsgType type, MsgQueId reply)

          static err_t sendIsr(MsgQueId dest, MsgPri pri, MsgType type, MsgQueId reply, const void* param, size_t param_size)
 
          template<typename T>
          static err_t MsgLib::sendIsr(MsgQueId dest, MsgPri pri, MsgType type, MsgQueId reply, const T& param)
  -----------------------------------------------------------------------

  [引数]   MsgQueId    dest       : 送信先メッセージキューID
           MsgPri      pri        : メッセージの優先度
           MsgType     type       : メッセージ種別を識別するための値
           MsgQueId    reply      : 返信先メッセージキューID
           const T&    param      : メッセージのパラメタ
           size_t      param_size : パラメータサイズ

  [戻り値] ERR_OK        : 送信成功
           ERR_QUE_FULL  : メッセージキューに空きがない
           ERR_DATA_SIZE : 引数paramのサイズが大きすぎてキューに格納できない
           ERR_ARG       : 引数destの示すメッセージキューブロックが存在しない
           ERR_STS       : MsgLib::initFirst()が未実行

  [説明]   引数destとpriで示されるキューに、メッセージパケットを格納する。
	send()はタスクコンテキスト、sendIsr()は非タスクコンテキストで使用する。
	sendIsr()でパラメタを使用する場合、割込み処理の最短化のため、できるだけ
	クラスインスタンスは使用せず、パラメタサイズも最小化する事。

	typename Tのサイズ、引数param_sizが大きすぎてキューに格納できない場合は、ERR_DATA_SIZEを返す。
	引数destとpriで示されるキューが存在しない場合は、ERR_ARGを返す。
	初期化が完了していない場合は、ERR_STSを返す。
	他CPU所有で、自CPUとのスピンロック共有がないキューを指定した場合は、ASSERTする。

	sendIsr()で、共有キューを指定した場合は、ASSERTする。
	これは、非タスクコンテキストでのスピンロック待ちを防止するためである。

  [互換性] Message::psend(), Message::isend(), PMessage::psendParam(), MessageTrySendParam()に類似


8.2.1.6 メッセージキューブロックへの参照を取得

  -----------------------------------------------------------------------
  [関数]  static err_t MsgLib::referMsgQueBlock(MsgQueId id, MsgQueBlock **que)
  -----------------------------------------------------------------------

  [引数]   MsgQueId    id    : メッセージキューID
           MsgQueBlock **que : メッセージキューブロックの参照

  [戻り値] ERR_OK  : 取得成功
           ERR_ARG : 引数idの示すメッセージキューブロックが存在しない、あるいはqueがNULL
           ERR_STS : MsgLib::initFirst()が未実行

  [説明]   メッセージキューブロックへの参照を取得する。
	引数idの示すメッセージキューブロックが存在しないか、あるいは初期化が完了して
	いない場合は、ASSERTする。

	※ MsgQueBlock::pop()のために、constなしの参照を返す。

  [互換性] なし


8.2.1.7 メッセージ受信を通知

  -----------------------------------------------------------------------
  [関数]  static err_t MsgLib::notifyRecv(MsgQueId dest)
  -----------------------------------------------------------------------

  [引数]   MsgQueId    dest  : 通知先メッセージキューID

  [戻り値] ERR_OK  : 通知成功
           ERR_ARG : 引数destの示すメッセージキューブロックが存在しない
           ERR_STS : MsgLib::initFirst()が未実行

  [説明]   他CPUからのメッセージの受信を通知する。
	本関数は、CPU間通信割込みハンドラから呼び出されることを想定している。

  [互換性] なし


8.2.2 MsgQueBlockクラス

8.2.2.1 メッセージパケットの受信

  -----------------------------------------------------------------------
  [関数]  MsgPacket* MsgQueBlock::recv(uint32_t ms)
  -----------------------------------------------------------------------

  [引数]   uint32_t  ms : 受信待ち時間(ミリ秒)または、TIME_POLLING or TIME_FOREVER

  [戻り値] NULL以外: メッセージキュー内のメッセージパケットへのポインタ
           NULL:     受信タイムアウト

  [説明]   指定された時間、メッセージパケットの受信待ちを行う。
	MsgLib::send()とは異なり、複数タスクによる同一キューへの同時recv()は
	サポートしない。
	os_wrap.hで、TIME_POLLINGは0、TIME_FOREVERは-1に定義されている。

	前回受信したメッセージパケットが、MsgQueBlock::pop()により破棄されて
	いない場合は、ASSERTする。
	メッセージキューが他CPU所有の場合は、ASSERTする。

  [互換性] Message::receive()に類似


8.2.2.2 メッセージパケットの破棄

  -----------------------------------------------------------------------
  [関数]  void MsgQueBlock::pop()
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] なし

  [説明]   メッセージキューからメッセージパケットを取り除く。
	メッセージパケットにパラメタが存在する場合は、MsgPacket::moveParam()か
	MsgPacket::popParam()により、事前にパラメタを破棄すること。
	複数タスクによる同一キューの同時pop()はサポートしない。

	破棄対象メッセージパケットが存在しない場合は、ASSERTする。
	破棄対象メッセージパケットのパラメタ長が、0以外の場合は、ASSERTする。
	メッセージキューが他CPU所有の場合は、ASSERTする。

  [互換性] なし


8.2.2.3 メッセージキュー所有者(受信者)のCPU-IDの取得

  -----------------------------------------------------------------------
  [関数]  MsgCpuId MsgQueBlock::getOwner() const
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] CPU-ID

  [説明]   メッセージキューの所有者(受信者)のCPU-IDを取得する。

  [互換性] なし


8.2.2.4 共有キューか否かを取得

  -----------------------------------------------------------------------
  [関数]  bool MsgQueBlock::isShare() const
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] true:  共有キュー
           false: 非共有キュー

  [説明]   メッセージキューが共有キューか否かを取得する。

  [互換性] なし


8.2.2.5 メッセージパケット数の取得

  -----------------------------------------------------------------------
  [関数]  uint16_t MsgQueBlock::getNumMsg(MsgPri pri) const
  -----------------------------------------------------------------------

  [引数]   MsgPri    pri  : メッセージキュー優先度

  [戻り値] メッセージパケット数

  [説明]   メッセージキュー内のメッセージパケット数を取得する。
	引数priの値が不正な場合は、ASSERTする。

  [互換性] なし


8.2.2.6 格納可能なメッセージパケット数の取得

  -----------------------------------------------------------------------
  [関数]  uint16_t MsgQueBlock::getRest(MsgPri pri) const
  -----------------------------------------------------------------------

  [引数]   MsgPri    pri  : メッセージキュー優先度

  [戻り値] 格納可能なメッセージパケット数

  [説明]   メッセージキューに格納可能なメッセージパケット数を取得する。
	未使用のキューは、常に0を返す。
	引数priの値が不正な場合は、ASSERTする。

  [互換性] なし


8.2.3 MsgPacketクラス

8.2.3.1 メッセージタイプIDの取得

  -----------------------------------------------------------------------
  [関数]  MsgType MsgPacket::getType() const
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] メッセージタイプID

  [説明]   メッセージパケットのタイプIDを取得する。

  [互換性] Message::get_type()


8.2.3.2 メッセージリプライキューIDの取得

  -----------------------------------------------------------------------
  [関数]  MsgQueId MsgPacket::getReply() const
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] リプライキューID

  [説明]   メッセージパケットのリプライキューIDを取得する。

  [互換性] Message::get_res()相当


8.2.3.3 メッセージ送信元CPU-IDの取得

  -----------------------------------------------------------------------
  [関数]  MsgCpuId MsgPacket::getSrcCpu() const
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] 送信元CPU-ID

  [説明]   メッセージパケットの送信元CPU-IDを取得する。

  [互換性] なし


8.2.3.4 メッセージフラグの取得

  -----------------------------------------------------------------------
  [関数]  uint8_t MsgPacket::getFlags() const
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] フラグ

  [説明]   メッセージパケットのフラグを取得する。
	現在フラグは、ライブラリ内部使用のみのため、本APIはデバッグ専用である。

  [互換性] なし


8.2.3.5 メッセージパラメタ長の取得

  -----------------------------------------------------------------------
  [関数]  uint16_t MsgPacket::getParamSize() const
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] メッセージパラメタ長。パラメタなし時は0が返される。

  [説明]   メッセージパケットのパラメタ長を取得する。

  [互換性] なし


8.2.3.6 メッセージパラメタの破壊取り出し(移動)

  -----------------------------------------------------------------------
  [関数]  template<typename T>
          T MsgPacket::moveParam()
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] メッセージパラメタ

  [説明]   メッセージパケットのパラメタを取り出す(移動)。
	sizeof(T) != getParamSize() の場合、ASSERTする。

	本APIは、以下の処理と等価となる。
		T param = peekParam<T>();	/* 左辺を非参照にして、パラメタのコピーを作成 */
		popParam<T>();			/* パラメタを破棄 */
		return param;			/* パラメタのコピーを返す */

	本APIの呼出しにより、メッセージパラメタ長が0に変更される。
	メッセージパラメタへの参照やポインタは無効となるので、注意すること。

  [互換性] PMessage::getParam(), MessageGetParam()に類似


8.2.3.7 メッセージパラメタ参照の取得

  -----------------------------------------------------------------------
  [関数]  template<typename T>
          const T& MsgPacket::peekParam() const

          template<typename T>
          const T& MsgPacket::peekParamOther() const
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] メッセージパラメタのconst参照

  [説明]   メッセージパケットのパラメタへの参照を取得する。
	peekParam()は、送信時と同じ型、peekParamOther()は、送信時と異なる型
	(例えばパラメタのヘッダの型)での参照に使用する。

	peekParam()は、sizeof(T) != getParamSize() の場合、ASSERTする。
	peekParamOther()は、sizeof(T) > getParamSize() の場合、ASSERTする。

	これらのAPIの戻り値を非参照で受け取るとパラメタのコピーが取得できる。

  [互換性] PMessage::peekParam(), MessagePeekParam()に類似


8.2.3.8 メッセージパラメタの破棄

  -----------------------------------------------------------------------
  [関数]  template<typename T>
          void MsgPacket::popParam()

          void MsgPacket::popParamNoDestruct()
  -----------------------------------------------------------------------

  [引数]   なし

  [戻り値] なし

  [説明]   メッセージパケットのパラメタを破棄する。
	popParam()は、パラメタのデストラクタを呼出す。
	popParamNoDestruct()はデストラクタを呼出さないので、パラメタにデストラクタが
	存在しないメッセージパケットにのみ使用することができる。
	特別な理由がない限り、popParam()を使用すること。

	popParam()は、sizeof(T) != getParamSize() の場合、ASSERTする。

	これらのAPIの呼出しにより、メッセージパラメタ長が0に変更される。
	メッセージパラメタへの参照やポインタは無効となるので、注意すること。

  [互換性] PMessage::popParam(), MessagePopParam()に類似


------------------------------------------------------------------------
9. 使用例
------------------------------------------------------------------------

 (1) ライブラリ全体の初期化

	/* 単一のCPUで、一度だけ実行すること */
	SpinLockManager::initFirst();
	MsgLib::initFirst();

 (2) CPU毎のライブラリの初期化

	/* 各CPUで、一度だけ実行すること */
	SpinLockManager::initPerCpu();
	MsgLib::initPerCpu();

 (3) メッセージパケットの送信処理

	SampleParam param;

	/* MSGQ_SAMPLEキューへパラメタつきメッセージを送信 */
	err_t err = MsgLib::send(MSGQ_SAMPLE, MsgPriNormal, MSG_SAMPLE_WITH_PARAM, MSGQ_MINE, param);
	if (err != ERR_OK) /*** 送信エラー処理 ***/;

 (4) CPU間通信割込みハンドラの処理

	uint32_t id;

	/* CPU間通信レジスタから、メッセージキューIDを取得して、メッセージ受信を通知する */
	IO_REG_IN(FROM_XPU_REQ, id);
	MsgLib::notifyRecv(static_cast<MsgQueId>(id));

 (5) メッセージパケットの受信処理

	/* メッセージ受信キューへの参照を取得 */
	MsgQueBlock&	que = MsgLib::referMsgQueBlock(MSGQ_SAMPLE);
	for (;;) {
		MsgPacket* msg = que.recv(TIME_FOREVER);
		F_ASSERT(msg);	/* 無限待ち指定の場合、エラーは返らないはず */

		if (msg->getType() == MSG_SAMPLE_WITH_PARAM) {
			/*
			 * メッセージパラメタの破壊取り出し(移動)
			 * この方法は簡潔だが、コピーコンストラクタの処理が重い場合や
			 * パラメタサイズが大きい場合は、peekParam & popParamの方が望ましい
			 */
			SampleParam param = msg->moveParam<SampleParam>();

			/// paramを使用した処理 ///

		} else if (msg->getType() == MSG_SAMPLE_USING_PEEK_PARAM) {
			/* メッセージパラメタへの参照を取得 */
			const SampleParam& refParam = msg->peekParam<SampleParam>();

			/// refParamを使用した処理 ///

			/* メッセージパラメタを破棄する */
			msg->popParam<SampleParam>();
		} else if (msg->getType() == MSG_SAMPLE_USING_PEEK_PARAM_OTHER_AND_MORE) {
			/* メッセージパラメタをユーザー定義のヘッダ型で参照する */
			const SampleParamHeader& refHead = msg->peekParamOther<SampleParamHeader>();
			if (refHead.mode == MODE_A) {
				SampleParamModeA param = msg->moveParam<SampleParamModeA>();
				/// paramを使用した処理 ///
			} else {
				const SampleParamModeB& refParam = msg->peekParam<SampleParamModeB>();
				/// refParamを使用した処理 ///
				msg->popParam<SampleParamModeB>();
			}
		}
		/* 受信したメッセージパケットをキューから取り除く */
		que.pop();
	}


------------------------------------------------------------------------
10. デバッグサポート
------------------------------------------------------------------------

10.1 メッセージシーケンスログ

  ダンプレイアウト設定ファイルに、DMP_MSG_SEQ2エントリを追加することで、メッセージの
  シーケンスログを取得できる。
  送受信とログ書き込みの間で割込みが発生する可能性があるため、ログの並び順は
  前後する場合があるので注意すること。

  # [ ID,      		enable,	bytes,	num,	pri,	mode,	sem,	cache,	time,	sign]
    ["DMP_MSG_SEQ2",	true,	16,	512,	1,	1,	false,	false,	4,	""],

  LogAnalyzerでのメッセージシーケンスログ表示例を下記に示す。
  時間情報の後に、以下の項目が表示される。

	・API (S: send, I: sendIsr, R: recv)
	・対象キューID (Destination)
	・メッセージの優先度 (Pri)
	・対象キューIDの該当優先度のキュー内のメッセージ数 (Cnt)
	・メッセージのタイプID (Type)
	・メッセージの送信元CPU-ID (Cpu)
	・メッセージのパラメタ長およびパラメタ先頭4バイトのダンプ (Param)
	・メッセージのリプライキューID (Reply)
	・API実行タスク

                                                       API Destination      Pri Cnt Type  Cpu Param(Len,Head) Reply             Task
  [No.   0: Time=9be7571b (0day: 00:00:07.908:177:157)] R: MSGQ_TEST4      , 1,  2, 1155,  0,   4, 800429b0,  MSGQ_TEST9      , TEST4_TSK
  [No.   1: Time=9be76330 (0day: 00:00:07.908:186:509)] R: MSGQ_TEST4      , 1,  1, 1155,  0,   4, 80042870,  MSGQ_TEST8      , TEST4_TSK
  [No.   2: Time=9be76cf3 (0day: 00:00:07.908:194:065)] R: MSGQ_TEST7      , 1,  2, 1155,  0,   4, 800429c0,  MSGQ_TEST9      , TEST7_TSK
  [No.   3: Time=9be77908 (0day: 00:00:07.908:203:416)] R: MSGQ_TEST7      , 1,  1, 1155,  0,   4, 80042880,  MSGQ_TEST8      , TEST7_TSK
  [No.   4: Time=9bf08fee (0day: 00:00:07.910:004:432)] S: MSGQ_CYCLIC     , 0,  1, 0304,  0,   0, 00000002,  MSGQ_NULL       , DMY_TMR_TSK


10.2 メッセージピークログ

  ダンプレイアウト設定ファイルに、DMP_MSG_PEAKエントリを追加することで、メッセージの
  ピークログを取得できる。

  # [ ID,      		enable,	bytes,	num,	pri,	mode,	sem,	cache,	time,	sign]
    # numフィールドは、(NUM_MSGQ_POOLS - 1) * 2以上の値を指定すること
    ["DMP_MSG_PEAK",	true,	12,	6,	1,	2,	false,	false,	4],

  LogAnalyzerでのメッセージピークログ表示例を下記に示す。
  時間情報の後に、以下の項目が表示される。

	・キューID
	・優先度
	・ピークメッセージ数
	・ピークメッセージのタイプID
	・ピークメッセージのリプライキューID
	・ピークメッセージを送信したタスク

	ピークメッセージ数が2以上の場合は、追加で以下の項目が表示される。
	・キュー先頭のメッセージのタイプID
	・キュー先頭のメッセージのリプライキューID

  [No.   0: Time=00000002 (0day: 00:00:00.020:000:000)] MSGQ_TEST1               (Pri0): PeakCount=  1, PeakMsg=[Type=0403, Reply=MSGQ_CYCLIC, Task=CYCLIC_TSK]
  [No.   1: Time=00000000 (0day: 00:00:00.000:000:000)]                          (Pri1): PeakCount=  0
  [No.   2: Time=00000000 (0day: 00:00:00.000:000:000)] MSGQ_CYCLIC              (Pri0): PeakCount=  1, PeakMsg=[Type=8400, Reply=MSGQ_NULL, Task=ROOT_TSK]
  [No.   3: Time=00000000 (0day: 00:00:00.000:000:000)]                          (Pri1): PeakCount=  0
  [No.   4: Time=00000000 (0day: 00:00:00.000:000:000)] MSGQ_ROOT                (Pri0): PeakCount=  3, PeakMsg=[Type=dead, Reply=MSGQ_ROOT, Task=ROOT_TSK], TopMsg=[Type=1234, Reply=MSGQ_CYCLIC]
  [No.   5: Time=00000000 (0day: 00:00:00.000:000:000)]                          (Pri1): PeakCount=  0


10.3 ダンプ表示

  ISS環境かSIM環境であれば、下記のデバッグ専用APIを利用できる。
  内部でprintf()を使用しているので、EVA環境では事実上利用できない。

  SIM環境の場合は、事前にメッセージ領域を0クリアするなどしないと不定値参照が
  発生する可能性があるため、使用には注意が必要である。

	static void MsgLib::dump();		/* 全メッセージキューのダンプ */
	void MsgQueBlock::dump() const;		/* メッセージキューのダンプ */


10.4 メッセージ破棄後の領域のFILL

  メッセージキューレイアウト定義ファイルの設定により、メッセージ破棄後の領域を
  特定の値で埋めることができる。
  Debug用のmalloc/freeで用意されることの多い、free後の領域埋めと同様の機能である。
  10.5節のMessageLib管理領域のダンプを行う場合は、情報が消えてしまうので使用しない方が良い。

	###############################################################################
	# デバッグ用に、メッセージpop後の領域を埋める値を8bitで指定する
	# 0の時は領域埋めを行わない。デバッグ時以外は、0を指定すること
	#
	MsgFillValueAfterPop = 0x00


10.5 メッセージパラメタの型チェック

  メッセージキューレイアウト定義ファイルの設定により、CPU内メッセージのパラメタ
  の型チェックを行うことができる。

	###############################################################################
	# メッセージパラメタの型が送受信で一致するかのチェックの有無を指定する
	# チェックは、const/volatileを含めて厳密に行われる
	# CPU内メッセージのみが対象となる
	# trueを指定すると要素サイズが8より大きいキューの各要素に4バイトの領域が追加され
	# 処理時間も増加する。ISS環境以外では、通常はfalseを指定すること
	#
	MsgParamTypeMatchCheck = false


10.6 MessageLib管理領域のダンプ

10.6.1 ダンプ方法

  ISS環境やSIM環境などで、プログラムからダンプを行いたい場合は
  Sample/withCyclic_Msg2.0/BSP/ISS_ALLEGRO/exit.cを参照のこと。

  SIM環境の場合は、事前にメッセージ領域を0クリアするなどしないと不定値参照が
  発生する可能性があるため、使用には注意が必要である。

  JTAG ICEやHostのコマンドでのダンプは、該当する資料を参照のこと。


10.6.2 解析コマンド

  解析コマンドの書式を以下に示す。

	ruby msgq_dump.rb msgq_id.h dump_file

  コマンド引数
		msgq_id.h	メッセージキューIDファイル
		dump_file	MessageLib管理領域のダンプファイル


------------------------------------------------------------------------
11. アサート
------------------------------------------------------------------------

  本ライブラリで発生する可能性があるASSERTについて説明する。
  ファイル名や行番号は、ソースの修正にともない変更されることがあるため
  ASSERTを発生させた式で説明を行う。

  (1) "mqb[id].m_id == id"

	発生場所: MsgLib::initPerCpu(), MsgLib::referMsgQueBlock()

	説明: MsgLib::initFirst()が実行されていない

  (2) "(*&m_count_sem = acre_sem(&_cfg_)) > 0"

	発生場所: MsgQueBlock::setup()

	説明: Makefile.sailで予約したセマフォの数が不足している。7.1.1節を参照のこと

  (3) "m_initDone == false"

	発生場所: MsgQueBlock::setup()

	説明: 同一CPUで、MsgLib::initPerCpu()を複数回呼出した

  (4) "isInit()"

	発生場所: MsgQueBlock::getNumMsg(), MsgQueBlock::getRest(), MsgQueBlock::pushHeader(),
		  MsgQueBlock::recv(), MsgQueBlock::pop()

	説明: MsgLib::initPerCpu()が実行されていない

  (5) "isOwn()"

	発生場所: MsgQueBlock::pushHeader(), MsgQueBlock::recv(), MsgQueBlock::pop()

	説明: 自CPU所有のキューにしか実行できないAPIを呼び出した

  (6) "sizeof(T) == getParamSize()"

	発生場所: MsgPacket::peekParam(), MsgPacket::popParam()

	説明: 型Tのサイズが、メッセージパケットのパラメタ長と異なる

  (7) "sizeof(T) <= getParamSize()"

	発生場所: MsgPacket::peekParamOther()

	説明: 型Tのサイズが、メッセージパケットのパラメタ長よりも大きい


  (8) "msg->getParamSize() == 0"

	発生場所: MsgQueBlock::pop()

	説明: 破棄対象のメッセージパケットから、パラメタが取り除かれていない

  (9) "m_cur_que"

	発生場所: MsgQueBlock::pop()

	説明: メッセージパケットの受信なしに、MsgQueBlock::pop()を呼出した

  (10) "m_cur_que == NULL"

	発生場所: MsgQueBlock::recv()

	説明: 以前受信したメッセージパケットの破棄なしに、MsgQueBlock::recv()を呼出した

  (11) "m_que[pri].is_init()"

	発生場所: MsgQueBlock::pushHeader()

	説明: メッセージパケットの送信先に、未使用の高優先度キューを指定した

  (12) "que.isShare() == false"

	発生場所: MsgLib::sendIsrImpl()

	説明: ISRから共有キューへのメッセージ送信は禁止されている

  (13) "id != MSGQ_NULL && id < NUM_MSGQ_POOLS"

	発生場所: MsgLib::referMsgQueBlock()

	説明: 引数のidに不正な値が指定された

  (14) "pri == MsgPriNormal || pri == MsgPriHigh"

	発生場所: MsgQueBlock::pushHeader(), MsgQueBlock::getNumMsg(), MsgQueBlock::getRest()

	説明: 引数のpriに不正な値が指定された

  (15) "full_size <= que.getElemSize(pri)"

	発生場所: MsgLib::sendImpl(), MsgLib::sendIsrImpl()

	説明: キューの要素サイズを超えるサイズのメッセージパケットを送信しようとした

  (16) "this->is_type<T>()"

	発生場所: TypeHolderBase::get()

	説明: 送信時のパラメタ型と異なる型で、MsgPacket::moveParam() or MsgPacket::peekParam()を呼出した

  (17) "sizeof(T) <= this->size()"

	発生場所: TypeHolderBase::get_any()

	説明: 送信時のパラメタ型よりもサイズの大きい型で、MsgPacket::peekParamOther()を呼出した

  (18) "reinterpret_cast<TypeHolderBase*>(&m_param[0])->template is_type<T>()"

	発生場所: MsgPacket::popParam()

	説明: 送信時のパラメタ型と異なる型で、MsgPacket::popParam()を呼出した


------------------------------------------------------------------------
12. Q & A
------------------------------------------------------------------------

Q1. 送信完了までブロックするAPIが用意されない背景は？

A1. 以下の通りです。

 1. キューフルは、ユーザーが認識すべき事象である
　　完了復帰のsend使用時は、メッセージ処理が滞っている場合に、割込みハンドラか
　　Cyclicタスクのメッセージ送信が失敗してASSERTすることで、キューフルに気が付きます。
　　割込みハンドラからは完了復帰のsendは使えませんので、そのキューが同時に受信しうる
　　キュー段数を確保する必要があることは明らかです。

　　またメッセージ処理が滞り始めてから、キューフル検出までに時間がかかると滞りの原因の
　　ログが流れてしまう可能性があります。

 2. タスクの処理遅延
　　sendの完了に長時間の待ちが発生した場合、どんなに自タスクの優先度が高くても
　　緊急の受信メッセージに即座に対応できません。
　　また特定のタスクの時々の処理遅延は、sendの完了待ちが発生しているせいかもしれません。

　　イベントドリブンなシステムでは、イベントループ受信待ち以外の箇所で待ち状態になるのは
　　設計上好ましくありません。

 3. OSリソース
　　MsgLib2.0では、キューでの受信待ちを行うために各キューに1つセマフォを使用しています。
　　sendの完了復帰をサポートするためには、各キューに更に2つ(優先度数分)の送信完了待ち用の
　　OS同期リソースを割当てる必要があります(通常は速度や処理の対称性からセマフォでしょう)。

　　例えばReimsでは66のDTQを使っていますので、MsgLib2.0に変更してsend完了復帰を
　　サポートする場合は、最大で198個のセマフォが必要となります。
　　セマフォはMemMgrやDumpLib, CacheLibなどでも使っていますが、SailOS+では最大255個まで
　　しか確保できないリソースですので、枯渇する危険性があり注意が必要です。

 4. マルチプロセッサのサポートが非常に難しい
　　自CPU向けだけ完了復帰をサポートするという手もありますが、できるだけシームレスに
　　マルチプロセッサをサポートするという基本方針に反します。

　　例えばFecampのように当初はSpu0のみだが、処理能力が溢れたら一部のタスクをSpu1に
　　移動することを考えているシステムの場合、タスクのCPU移動に伴いsend完了復帰を前提に
　　していた全ての箇所を書き直してテストしなおす必要が出てきます。
　　そのため完了復帰は全てサポートしないこととしました。


Q2. send完了復帰を前提にしていた既存のプログラムは、どう対応すべき？

A2. そのキューが同時に受信しうるメッセージ数を見積もって、十分なキュー段数を設定する
　　ことで常に送信完了復帰となります。
　　バースト的に大量にメッセージを送信するタスクがある場合は、そのタスクとの間に
　　流量制限の取り決めを行う必要があるでしょう。

　　既存のプログラムを直す余裕がない場合は、ポーリングで送信リトライを行うラッパ
　　関数が include/sample/MsgWrapper.h に用意されています。
　　各々の環境向けにカスタマイズしてご利用下さい。

